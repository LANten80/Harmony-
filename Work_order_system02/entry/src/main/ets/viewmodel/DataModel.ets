/**
 * æ•°æ®æ“ä½œæ¨¡å‹
 * å•ä¾‹æ¨¡å¼ç®¡ç†å·¥å•æ•°æ®
 * ä½¿ç”¨åç«¯APIè¿›è¡Œæ•°æ®æ“ä½œ
 */

import { TaskItemModel, TaskStatus, TaskPriority } from './TaskItemModel';
import { StatisticsModel } from './StatisticsModel';
import { apiService, TaskData as ApiTaskData } from '../common/api/ApiService';
import { TaskData } from '../common/types/TaskData';
import { common } from '@kit.AbilityKit';
import { logger } from '../common/utils/Logger';
import { UserStorageUtil } from '../common/utils/UserStorageUtil';
import { httpUtil } from '../common/utils/HttpUtil';

/**
 * æ•°æ®æ¨¡å‹å•ä¾‹ç±»
 */
export class DataModel {
  private static instance: DataModel;
  private targetData: TaskItemModel[] = [];
  private context: common.UIAbilityContext | null = null;
  
  // æ ‡è®°æ˜¯å¦å·²ç»ä»åç«¯åŠ è½½è¿‡æ•°æ®ï¼ˆé¿å…é‡å¤åŠ è½½ï¼‰
  private dataLoadedFromApi: boolean = false;
  
  // æ˜¯å¦æ­£åœ¨åŠ è½½æ•°æ®ï¼ˆé˜²æ­¢å¹¶å‘è¯·æ±‚ï¼‰
  private isLoading: boolean = false;

  // æ•°æ®å˜æ›´ç›‘å¬å™¨
  private changeListeners: Array<() => void> = [];

  /**
   * ç§æœ‰æ„é€ å‡½æ•°ï¼Œå®ç°å•ä¾‹æ¨¡å¼
   */
  private constructor() {
    // ä¸åœ¨è¿™é‡Œåˆå§‹åŒ–æ•°æ®ï¼Œç­‰å¾… loadData è°ƒç”¨
  }

  /**
   * è®¾ç½®åº”ç”¨ä¸Šä¸‹æ–‡
   */
  setContext(context: common.UIAbilityContext): void {
    this.context = context;
  }

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  static getInstance(): DataModel {
    if (!DataModel.instance) {
      DataModel.instance = new DataModel();
    }
    return DataModel.instance;
  }

  /**
   * åˆå§‹åŒ–ç©ºæ•°æ®
   */
  private initEmptyData(): void {
    this.targetData = [];
  }

  /**
   * æ¸…é™¤æ•°æ®çŠ¶æ€ï¼ˆé€€å‡ºç™»å½•æ—¶è°ƒç”¨ï¼‰
   */
  clearData(): void {
    const beforeCount = this.targetData.length;
    logger.error('âš ï¸âš ï¸âš ï¸ DataModel.clearData: å¼€å§‹æ¸…é™¤æ•°æ®çŠ¶æ€ï¼Œå½“å‰å·¥å•æ•°: ' + String(beforeCount));
    logger.error('âš ï¸âš ï¸âš ï¸ DataModel.clearData: æ¸…é™¤å‰çš„æ•°æ®IDåˆ—è¡¨: ' + JSON.stringify(this.targetData.map(item => item.id)));
    this.targetData = [];
    this.dataLoadedFromApi = false;
    this.isLoading = false;
    logger.error('âš ï¸âš ï¸âš ï¸ DataModel.clearData: æ•°æ®çŠ¶æ€å·²æ¸…é™¤ï¼ŒdataLoadedFromApi=false, isLoading=false');
    logger.error('âš ï¸âš ï¸âš ï¸ DataModel.clearData: æ¸…é™¤åçš„å·¥å•æ•°: ' + String(this.targetData.length));
  }

  /**
   * å°†APIè¿”å›çš„TaskDataè½¬æ¢ä¸ºTaskItemModel
   */
  private convertApiTaskToModel(apiTask: ApiTaskData): TaskItemModel | null {
    try {
      if (!apiTask) {
        logger.warn('DataModel.convertApiTaskToModel: apiTaskä¸ºç©º');
        return null;
      }
      
      if (!apiTask.taskName) {
        logger.warn('DataModel.convertApiTaskToModel: taskNameä¸ºç©º', JSON.stringify(apiTask));
        return null;
      }

      const progressValue = apiTask.progressValue !== undefined ? apiTask.progressValue : 0;
      const priority = apiTask.priority ? (apiTask.priority as TaskPriority) : TaskPriority.MEDIUM;
      
      const task = new TaskItemModel(
        apiTask.taskName,
        apiTask.description || '',
        progressValue,
        priority
      );
      
      if (apiTask.id) {
        task.id = apiTask.id;
      }
      
      if (apiTask.status) {
        task.status = apiTask.status as TaskStatus;
      }
      
      if (apiTask.createDate) {
        task.createDate = apiTask.createDate;
      }
      
      if (apiTask.updateDate) {
        task.updateDate = apiTask.updateDate;
      }
      
      task.dueDate = apiTask.dueDate || '';
      task.assignee = apiTask.assignee || '';
      task.category = apiTask.category || '';
      task.tags = apiTask.tags || [];
      
      logger.info('DataModel.convertApiTaskToModel: è½¬æ¢æˆåŠŸ, taskId: ' + task.id + ', taskName: ' + task.taskName);
      return task;
    } catch (err) {
      logger.error('DataModel.convertApiTaskToModel: è½¬æ¢å¤±è´¥', JSON.stringify(err));
      return null;
    }
  }

  /**
   * å°†TaskItemModelè½¬æ¢ä¸ºAPIè¯·æ±‚çš„TaskData
   */
  private convertModelToApiTask(task: TaskItemModel): ApiTaskData {
    return {
      id: task.id,
      taskName: task.taskName,
      description: task.description,
      progressValue: task.progressValue,
      status: task.status as string,
      priority: task.priority as string,
      createDate: task.createDate,
      updateDate: task.updateDate,
      dueDate: task.dueDate,
      assignee: task.assignee,
      category: task.category,
      tags: task.tags
    };
  }

  /**
   * ä»åç«¯APIåŠ è½½æ•°æ®ï¼ˆåªåœ¨é¦–æ¬¡è°ƒç”¨æ—¶åŠ è½½ï¼Œé¿å…é‡å¤åŠ è½½ï¼‰
   */
  async loadDataFromStorage(): Promise<void> {
    logger.error('ğŸ”µğŸ”µğŸ”µ DataModel.loadDataFromStorage: å¼€å§‹åŠ è½½æ•°æ®');
    logger.error('ğŸ”µğŸ”µğŸ”µ DataModel.loadDataFromStorage: dataLoadedFromApi=' + String(this.dataLoadedFromApi));
    logger.error('ğŸ”µğŸ”µğŸ”µ DataModel.loadDataFromStorage: isLoading=' + String(this.isLoading));
    logger.error('ğŸ”µğŸ”µğŸ”µ DataModel.loadDataFromStorage: å½“å‰å†…å­˜ä¸­çš„å·¥å•æ•°=' + String(this.targetData.length));
    
    // å¦‚æœå·²ç»åŠ è½½è¿‡ï¼Œç›´æ¥è¿”å›ï¼Œé¿å…é‡å¤åŠ è½½
    if (this.dataLoadedFromApi) {
      logger.error('âš ï¸âš ï¸âš ï¸ DataModel.loadDataFromStorage: æ•°æ®å·²åŠ è½½è¿‡ï¼Œè·³è¿‡é‡å¤åŠ è½½ï¼å½“å‰å·¥å•æ•°: ' + String(this.targetData.length));
      logger.error('âš ï¸âš ï¸âš ï¸ DataModel.loadDataFromStorage: å¦‚æœæ•°æ®ä¸ºç©ºï¼Œè¿™å¯èƒ½æ˜¯é—®é¢˜æ‰€åœ¨ï¼');
      return;
    }
    
    // å¦‚æœæ­£åœ¨åŠ è½½ï¼Œç­‰å¾…å®Œæˆ
    if (this.isLoading) {
      logger.info('DataModel.loadDataFromStorage: æ­£åœ¨åŠ è½½ä¸­ï¼Œè·³è¿‡é‡å¤è¯·æ±‚');
      return;
    }
    
    this.isLoading = true;
    logger.error('ğŸ”µğŸ”µğŸ”µ DataModel.loadDataFromStorage: å¼€å§‹ä»åç«¯APIåŠ è½½æ•°æ®');
    
    // ç¡®ä¿tokenå·²è®¾ç½®ï¼ˆä»sessionæ¢å¤ï¼‰
    if (this.context) {
      try {
        const session = await UserStorageUtil.loadSession(this.context);
        if (session && session.token) {
          httpUtil.setAuthToken(session.token);
          logger.error('ğŸ”µğŸ”µğŸ”µ DataModel.loadDataFromStorage: å·²ä»sessionæ¢å¤token: ' + session.token.substring(0, 20) + '...');
          logger.error('ğŸ”µğŸ”µğŸ”µ DataModel.loadDataFromStorage: session.currentUserId=' + (session.currentUserId || 'ç©º'));
        } else {
          logger.error('âŒâŒâŒ DataModel.loadDataFromStorage: sessionä¸­æ²¡æœ‰tokenï¼Œå¯èƒ½æœªç™»å½•ï¼');
          logger.error('âŒâŒâŒ DataModel.loadDataFromStorage: sessionå†…å®¹=' + JSON.stringify(session));
        }
      } catch (err) {
        logger.error('âŒâŒâŒ DataModel.loadDataFromStorage: æ¢å¤tokenå¤±è´¥: ' + JSON.stringify(err));
      }
    } else {
      logger.error('âŒâŒâŒ DataModel.loadDataFromStorage: contextä¸ºç©ºï¼Œæ— æ³•æ¢å¤tokenï¼');
    }
    
    try {
      logger.error('ğŸ”µğŸ”µğŸ”µ DataModel.loadDataFromStorage: å‡†å¤‡è°ƒç”¨ apiService.getTaskList()');
      const response = await apiService.getTaskList();
      logger.error('ğŸ”µğŸ”µğŸ”µ DataModel.loadDataFromStorage: APIå“åº”code=' + String(response.code));
      logger.error('ğŸ”µğŸ”µğŸ”µ DataModel.loadDataFromStorage: APIå“åº”data=' + JSON.stringify(response.data).substring(0, 200) + '...');
      
      if (response.code >= 200 && response.code < 300 && response.data) {
        // å¤„ç†åç«¯å¯èƒ½è¿”å›çš„åµŒå¥—å“åº”æ ¼å¼ï¼š{code: 200, message: "...", data: {list: [...]}}
        // ä½¿ç”¨JSONåºåˆ—åŒ–/ååºåˆ—åŒ–æ¥å®‰å…¨åœ°å¤„ç†ç±»å‹è½¬æ¢
        const responseDataStr = JSON.stringify(response.data);
        const responseDataParsed = JSON.parse(responseDataStr) as Record<string, string | number | boolean | null | undefined | ApiTaskData[] | Record<string, ApiTaskData[]>>;
        
        // æ£€æŸ¥æ˜¯å¦æ˜¯åµŒå¥—æ ¼å¼ï¼ˆæœ‰codeå’Œmessageå±æ€§ï¼‰
        const hasCode = responseDataParsed['code'] !== undefined;
        const hasMessage = responseDataParsed['message'] !== undefined;
        const hasData = responseDataParsed['data'] !== undefined;
        
        let taskList: ApiTaskData[] = [];
        
        if (hasCode && hasMessage && hasData) {
          // åµŒå¥—æ ¼å¼ï¼šä» data å­—æ®µä¸­æå–åˆ—è¡¨æ•°æ®
          const nestedData = responseDataParsed['data'];
          if (nestedData && typeof nestedData === 'object') {
            const nestedDataStr = JSON.stringify(nestedData);
            const nestedDataParsed = JSON.parse(nestedDataStr) as Record<string, ApiTaskData[]>;
            // å…¼å®¹ä¸åŒçš„åç«¯å“åº”æ ¼å¼ï¼šlist æˆ– data
            taskList = (nestedDataParsed['list'] || nestedDataParsed['data'] || []) as ApiTaskData[];
            logger.info('DataModel.loadDataFromStorage: æ£€æµ‹åˆ°åµŒå¥—æ ¼å¼ï¼Œä»dataå­—æ®µæå–åˆ—è¡¨æ•°æ®');
          }
        } else {
          // éåµŒå¥—æ ¼å¼ï¼šç›´æ¥ä½¿ç”¨response.data
          // å…¼å®¹ä¸åŒçš„åç«¯å“åº”æ ¼å¼ï¼šlist æˆ– data
          taskList = (responseDataParsed['list'] || responseDataParsed['data'] || []) as ApiTaskData[];
          logger.info('DataModel.loadDataFromStorage: ä½¿ç”¨éåµŒå¥—æ ¼å¼çš„å“åº”æ•°æ®');
        }
        
        logger.info('DataModel.loadDataFromStorage: ä»åç«¯åŠ è½½çš„æ•°æ®æ•°é‡:', String(taskList.length));
        
        if (taskList.length > 0) {
          const validTasks: TaskItemModel[] = [];
          
          taskList.forEach((item: ApiTaskData, index: number) => {
            const task = this.convertApiTaskToModel(item);
            if (task) {
              validTasks.push(task);
            } else {
              logger.warn(`DataModel.loadDataFromStorage: è·³è¿‡æ— æ•ˆæ•°æ®é¡¹ ${index}`);
            }
          });

          if (validTasks.length > 0) {
            this.targetData = validTasks;
            logger.error('âœ…âœ…âœ… DataModel.loadDataFromStorage: æˆåŠŸåŠ è½½ ' + String(validTasks.length) + ' ä¸ªå·¥å•');
            logger.error('âœ…âœ…âœ… DataModel.loadDataFromStorage: åŠ è½½çš„å·¥å•IDåˆ—è¡¨: ' + JSON.stringify(validTasks.map(item => item.id)));
            this.dataLoadedFromApi = true;
          } else {
            logger.error('âš ï¸âš ï¸âš ï¸ DataModel.loadDataFromStorage: æ²¡æœ‰æœ‰æ•ˆçš„å·¥å•æ•°æ®ï¼Œä½¿ç”¨ç©ºæ•°ç»„ï¼');
            logger.error('âš ï¸âš ï¸âš ï¸ DataModel.loadDataFromStorage: taskList.length=' + String(taskList.length) + ', validTasks.length=0');
            this.initEmptyData();
            this.dataLoadedFromApi = true;
          }
        } else {
          logger.error('âš ï¸âš ï¸âš ï¸ DataModel.loadDataFromStorage: åç«¯æ²¡æœ‰æ•°æ®ï¼Œä½¿ç”¨ç©ºæ•°ç»„ï¼');
          logger.error('âš ï¸âš ï¸âš ï¸ DataModel.loadDataFromStorage: taskList.length=0');
          this.initEmptyData();
          this.dataLoadedFromApi = true;
        }
      } else {
        logger.error('âŒâŒâŒ DataModel.loadDataFromStorage: è·å–æ•°æ®å¤±è´¥ï¼Œå“åº”ç : ' + String(response.code));
        logger.error('âŒâŒâŒ DataModel.loadDataFromStorage: å“åº”æ•°æ®: ' + JSON.stringify(response.data));
        this.initEmptyData();
        this.dataLoadedFromApi = true;
      }
    } catch (err) {
      logger.error('âŒâŒâŒ DataModel.loadDataFromStorage: åŠ è½½æ•°æ®å¤±è´¥: ' + JSON.stringify(err));
      logger.error('âŒâŒâŒ DataModel.loadDataFromStorage: é”™è¯¯ç±»å‹: ' + (err instanceof Error ? err.constructor.name : typeof err));
      if (err instanceof Error) {
        logger.error('âŒâŒâŒ DataModel.loadDataFromStorage: é”™è¯¯æ¶ˆæ¯: ' + err.message);
        if (err.stack) {
          logger.error('âŒâŒâŒ DataModel.loadDataFromStorage: é”™è¯¯å †æ ˆ: ' + err.stack);
        }
      }
      // åŠ è½½å¤±è´¥æ—¶ä½¿ç”¨ç©ºæ•°ç»„
      this.initEmptyData();
      this.dataLoadedFromApi = true;
    } finally {
      this.isLoading = false;
    }
    
    logger.error('ğŸ”µğŸ”µğŸ”µ DataModel.loadDataFromStorage: æ•°æ®åŠ è½½å®Œæˆï¼Œå½“å‰å·¥å•æ•°: ' + String(this.targetData.length));
    logger.error('ğŸ”µğŸ”µğŸ”µ DataModel.loadDataFromStorage: dataLoadedFromApi=' + String(this.dataLoadedFromApi));
    logger.error('ğŸ”µğŸ”µğŸ”µ DataModel.loadDataFromStorage: æœ€ç»ˆå·¥å•IDåˆ—è¡¨: ' + JSON.stringify(this.targetData.map(item => item.id)));
  }
  
  /**
   * å¼ºåˆ¶ä»åç«¯APIé‡æ–°åŠ è½½æ•°æ®ï¼ˆç”¨äºåˆ·æ–°åœºæ™¯ï¼‰
   */
  async reloadDataFromStorage(): Promise<void> {
    logger.info('DataModel.reloadDataFromStorage: å¼ºåˆ¶é‡æ–°åŠ è½½æ•°æ®');
    this.dataLoadedFromApi = false;
    this.isLoading = false;
    await this.loadDataFromStorage();
  }

  // æ³¨æ„ï¼šå·²ç§»é™¤saveDataToStorageæ–¹æ³•ï¼Œæ‰€æœ‰æ•°æ®æ“ä½œéƒ½é€šè¿‡åç«¯APIå®Œæˆ

  /**
   * è·å–æ‰€æœ‰å·¥å•æ•°æ®
   */
  getData(): TaskItemModel[] {
    console.info('DataModel.getData: è·å–æ•°æ®ï¼Œå½“å‰å·¥å•æ•°:', this.targetData.length);
    // è¿”å›æ•°ç»„çš„æ·±æ‹·è´ï¼Œç¡®ä¿æ¯æ¬¡è°ƒç”¨éƒ½è¿”å›æ–°æ•°ç»„
    const result = this.targetData.map(item => {
      const newItem = new TaskItemModel(item.taskName, item.description, item.progressValue, item.priority);
      newItem.id = item.id;
      newItem.status = item.status;
      newItem.createDate = item.createDate;
      newItem.updateDate = item.updateDate;
      newItem.dueDate = item.dueDate;
      newItem.assignee = item.assignee;
      newItem.category = item.category;
      newItem.tags = [...item.tags];
      return newItem;
    });
    console.info('DataModel.getData: è¿”å›æ•°æ®ï¼Œå·¥å•æ•°:', result.length);
    return result;
  }

  /**
   * æ·»åŠ å·¥å•ï¼ˆé€šè¿‡åç«¯APIï¼‰
   */
  async addData(taskName: string, description: string = ''): Promise<boolean> {
    if (!taskName || taskName.trim().length === 0) {
      logger.warn('DataModel.addData: å·¥å•åç§°ä¸ºç©º');
      return false;
    }

    logger.info('DataModel.addData: å¼€å§‹æ·»åŠ å·¥å•: ' + taskName);
    
    // ç¡®ä¿tokenå·²è®¾ç½®ï¼ˆä»sessionæ¢å¤ï¼‰
    let tokenRestored = false;
    if (this.context) {
      try {
        const session = await UserStorageUtil.loadSession(this.context);
        if (session && session.token) {
          httpUtil.setAuthToken(session.token);
          logger.info('DataModel.addData: å·²ä»sessionæ¢å¤token: ' + session.token.substring(0, 20) + '...');
          tokenRestored = true;
        } else {
          logger.warn('DataModel.addData: sessionä¸­æ²¡æœ‰tokenï¼Œå¯èƒ½æœªç™»å½•');
          logger.warn('DataModel.addData: sessionå†…å®¹: ' + JSON.stringify(session));
        }
      } catch (err) {
        logger.error('DataModel.addData: æ¢å¤tokenå¤±è´¥: ' + JSON.stringify(err));
      }
    } else {
      logger.error('DataModel.addData: contextä¸ºç©ºï¼Œæ— æ³•æ¢å¤token');
    }
    
    if (!tokenRestored) {
      logger.error('DataModel.addData: âš ï¸ è­¦å‘Šï¼štokenæœªæ¢å¤ï¼Œè¯·æ±‚å¯èƒ½ä¼šå¤±è´¥ï¼');
    }
    
    try {
      const apiTaskData: ApiTaskData = {
        taskName: taskName.trim(),
        description: description || '',
        progressValue: 0,
        status: TaskStatus.PENDING as string,
        priority: TaskPriority.MEDIUM as string
      };
      
      logger.info('DataModel.addData: å‡†å¤‡å‘é€APIè¯·æ±‚ï¼Œæ•°æ®: ' + JSON.stringify(apiTaskData));
      logger.info('DataModel.addData: è°ƒç”¨ apiService.createTask...');
      
      const response = await apiService.createTask(apiTaskData);
      
      logger.info('DataModel.addData: âœ… APIè¯·æ±‚å·²å®Œæˆï¼Œå“åº”code: ' + String(response.code));
      logger.info('DataModel.addData: APIå“åº”æ•°æ®: ' + JSON.stringify(response.data));
      
      // å¤„ç†åç«¯å¯èƒ½è¿”å›çš„åµŒå¥—å“åº”æ ¼å¼ï¼š{code: 200, message: "åˆ›å»ºæˆåŠŸ", data: {...}}
      if (response.code >= 200 && response.code < 300 && response.data) {
        // ä½¿ç”¨JSONåºåˆ—åŒ–/ååºåˆ—åŒ–æ¥å®‰å…¨åœ°å¤„ç†ç±»å‹è½¬æ¢ï¼ˆArkTSä¸å…è®¸unknownå’Œanyï¼‰
        const responseDataStr = JSON.stringify(response.data);
        const responseDataParsed = JSON.parse(responseDataStr) as Record<string, string | number | boolean | null | undefined | Record<string, string | number | boolean | null | undefined>>;
        
        // æ£€æŸ¥æ˜¯å¦æ˜¯åµŒå¥—æ ¼å¼ï¼ˆæœ‰codeå’Œmessageå±æ€§ï¼‰
        // ArkTSä¸æ”¯æŒinæ“ä½œç¬¦ï¼Œä½¿ç”¨æ£€æŸ¥undefinedçš„æ–¹å¼æ¥åˆ¤æ–­å±æ€§æ˜¯å¦å­˜åœ¨
        const hasCode = responseDataParsed['code'] !== undefined;
        const hasMessage = responseDataParsed['message'] !== undefined;
        const hasData = responseDataParsed['data'] !== undefined;
        
        let actualTaskData: ApiTaskData | null = null;
        
        if (hasCode && hasMessage && hasData) {
          // åµŒå¥—æ ¼å¼ï¼šä» data å­—æ®µä¸­æå–å·¥å•æ•°æ®
          const nestedData = responseDataParsed['data'];
          if (nestedData && typeof nestedData === 'object') {
            const nestedDataStr = JSON.stringify(nestedData);
            actualTaskData = JSON.parse(nestedDataStr) as ApiTaskData;
            logger.info('DataModel.addData: æ£€æµ‹åˆ°åµŒå¥—æ ¼å¼ï¼Œä»dataå­—æ®µæå–å·¥å•æ•°æ®');
          } else {
            logger.error('DataModel.addData: åµŒå¥—æ ¼å¼çš„dataå­—æ®µä¸æ˜¯å¯¹è±¡: ' + JSON.stringify(nestedData));
            return false;
          }
        } else {
          // éåµŒå¥—æ ¼å¼ï¼šç›´æ¥ä½¿ç”¨response.data
          actualTaskData = response.data as ApiTaskData;
          logger.info('DataModel.addData: ä½¿ç”¨éåµŒå¥—æ ¼å¼çš„å“åº”æ•°æ®');
        }
        
        if (actualTaskData) {
          const newTask = this.convertApiTaskToModel(actualTaskData);
          if (newTask) {
            this.targetData.push(newTask);
            logger.info('DataModel.addData: å·¥å•å·²æ·»åŠ åˆ°å†…å­˜ï¼Œå½“å‰å·¥å•æ•°: ' + String(this.targetData.length));
            
            // é€šçŸ¥å˜æ›´
            this.notifyChange();
            logger.info('DataModel.addData: å·¥å•åˆ›å»ºæˆåŠŸ');
            return true;
          } else {
            logger.error('DataModel.addData: è½¬æ¢å·¥å•æ•°æ®å¤±è´¥ï¼ŒactualTaskData: ' + JSON.stringify(actualTaskData));
            return false;
          }
        } else {
          logger.error('DataModel.addData: æ— æ³•æå–å·¥å•æ•°æ®');
          return false;
        }
      } else {
        logger.error('DataModel.addData: åˆ›å»ºå·¥å•å¤±è´¥ï¼Œå“åº”ç : ' + String(response.code) + ', message: ' + (response.message || ''));
        return false;
      }
    } catch (err) {
      logger.error('DataModel.addData: âŒ åˆ›å»ºå·¥å•å¼‚å¸¸ï¼');
      logger.error('DataModel.addData: å¼‚å¸¸ç±»å‹: ' + (err instanceof Error ? err.constructor.name : typeof err));
      logger.error('DataModel.addData: å¼‚å¸¸å†…å®¹: ' + JSON.stringify(err));
      if (err instanceof Error) {
        logger.error('DataModel.addData: é”™è¯¯æ¶ˆæ¯: ' + err.message);
        logger.error('DataModel.addData: é”™è¯¯å †æ ˆ: ' + (err.stack || 'æ— å †æ ˆä¿¡æ¯'));
      }
      return false;
    }
  }

  /**
   * æ›´æ–°å·¥å•è¿›åº¦ï¼ˆé€šè¿‡åç«¯APIï¼‰
   */
  async updateProgress(taskId: string, progressValue: number): Promise<boolean> {
    logger.info('DataModel.updateProgress: å¼€å§‹æ›´æ–°è¿›åº¦, taskId: ' + taskId + ', progressValue: ' + String(progressValue));
    
    // ç¡®ä¿è¿›åº¦å€¼åœ¨æœ‰æ•ˆèŒƒå›´å†…
    const validProgress = Math.max(0, Math.min(100, Math.round(progressValue)));
    logger.info('DataModel.updateProgress: éªŒè¯åçš„è¿›åº¦å€¼: ' + String(validProgress));
    
    const task = this.targetData.find(item => item.id === taskId);
    if (!task) {
      logger.error('DataModel.updateProgress: æœªæ‰¾åˆ°å·¥å•, taskId:', taskId);
      return false;
    }

    logger.info('DataModel.updateProgress: æ‰¾åˆ°å·¥å•, å½“å‰è¿›åº¦: ' + String(task.progressValue));
    
    try {
      // æ›´æ–°æœ¬åœ°æ•°æ®
      task.updateProgress(validProgress);
      task.updateDate = new Date().toISOString();
      
      // åŒæ­¥åˆ°åç«¯
      const apiTaskData = this.convertModelToApiTask(task);
      const response = await apiService.updateTask(taskId, apiTaskData);
      
      if (response.code >= 200 && response.code < 300) {
        logger.info('DataModel.updateProgress: å·¥å•è¿›åº¦å·²æ›´æ–°, æ–°è¿›åº¦å€¼: ' + String(task.progressValue));
        
        // é€šçŸ¥å˜æ›´
        this.notifyChange();
        logger.info('DataModel.updateProgress: è¿›åº¦æ›´æ–°æˆåŠŸ');
        return true;
      } else {
        logger.error('DataModel.updateProgress: æ›´æ–°å¤±è´¥ï¼Œå“åº”ç :', String(response.code));
        // å›æ»šæœ¬åœ°æ›´æ”¹
        await this.reloadDataFromStorage();
        return false;
      }
    } catch (err) {
      logger.error('DataModel.updateProgress: æ›´æ–°è¿›åº¦å¼‚å¸¸:', JSON.stringify(err));
      // å›æ»šæœ¬åœ°æ›´æ”¹
      await this.reloadDataFromStorage();
      return false;
    }
  }

  /**
   * åˆ é™¤å•ä¸ªå·¥å•ï¼ˆé€šè¿‡åç«¯APIï¼‰
   */
  async deleteTask(taskId: string): Promise<boolean> {
    logger.info('DataModel.deleteTask å¼€å§‹åˆ é™¤å·¥å•:', taskId);
    
    const index = this.targetData.findIndex(item => item.id === taskId);
    if (index === -1) {
      logger.warn('DataModel.deleteTask: å·¥å•IDä¸å­˜åœ¨:', taskId);
      return false;
    }

    const deletedTask = this.targetData[index];
    
    // ç¡®ä¿tokenå·²è®¾ç½®ï¼ˆä»sessionæ¢å¤ï¼‰
    let tokenRestored = false;
    if (this.context) {
      try {
        const session = await UserStorageUtil.loadSession(this.context);
        if (session && session.token) {
          httpUtil.setAuthToken(session.token);
          logger.info('DataModel.deleteTask: å·²ä»sessionæ¢å¤token: ' + session.token.substring(0, 20) + '...');
          tokenRestored = true;
        } else {
          logger.warn('DataModel.deleteTask: sessionä¸­æ²¡æœ‰tokenï¼Œå¯èƒ½æœªç™»å½•');
          logger.warn('DataModel.deleteTask: sessionå†…å®¹: ' + JSON.stringify(session));
        }
      } catch (err) {
        logger.error('DataModel.deleteTask: æ¢å¤tokenå¤±è´¥: ' + JSON.stringify(err));
      }
    } else {
      logger.error('DataModel.deleteTask: contextä¸ºç©ºï¼Œæ— æ³•æ¢å¤token');
    }
    
    if (!tokenRestored) {
      logger.error('DataModel.deleteTask: âš ï¸ è­¦å‘Šï¼štokenæœªæ¢å¤ï¼Œè¯·æ±‚å¯èƒ½ä¼šå¤±è´¥ï¼');
    }
    
    try {
      // è°ƒç”¨åç«¯APIåˆ é™¤
      const response = await apiService.deleteTask(taskId);
      
      if (response.code >= 200 && response.code < 300) {
        // ä»å†…å­˜ä¸­åˆ é™¤
        this.targetData.splice(index, 1);
        logger.info('DataModel.deleteTask: å·¥å•å·²åˆ é™¤:', deletedTask.taskName);
        
        // é€šçŸ¥å˜æ›´
        this.notifyChange();
        logger.info('DataModel.deleteTask: åˆ é™¤æˆåŠŸ');
        return true;
      } else {
        logger.error('DataModel.deleteTask: åˆ é™¤å¤±è´¥ï¼Œå“åº”ç :', String(response.code));
        return false;
      }
    } catch (err) {
      logger.error('DataModel.deleteTask: åˆ é™¤å·¥å•å¼‚å¸¸:', JSON.stringify(err));
      if (err instanceof Error) {
        throw err;
      } else {
        throw new Error(`åˆ é™¤å·¥å•å¤±è´¥: ${JSON.stringify(err)}`);
      }
    }
  }

  /**
   * æ‰¹é‡åˆ é™¤å·¥å•ï¼ˆé€šè¿‡åç«¯APIï¼‰
   */
  async deleteTasks(taskIds: string[]): Promise<number> {
    // æ ¡éªŒè¾“å…¥å‚æ•°
    if (!taskIds || taskIds.length === 0) {
      logger.warn('DataModel.deleteTasks: åˆ é™¤IDåˆ—è¡¨ä¸ºç©º');
      return 0;
    }

    // æ ¡éªŒæ•°æ®æºæœ‰æ•ˆæ€§
    if (!this.targetData || this.targetData.length === 0) {
      logger.warn('DataModel.deleteTasks: æ•°æ®æºä¸ºç©ºï¼Œæ— æ³•åˆ é™¤');
      return 0;
    }

    logger.info('DataModel.deleteTasks å¼€å§‹åˆ é™¤: ' + JSON.stringify(taskIds) + ', å½“å‰æ•°æ®é•¿åº¦: ' + String(this.targetData.length));
    
    // ç¡®ä¿tokenå·²è®¾ç½®ï¼ˆä»sessionæ¢å¤ï¼‰
    let tokenRestored = false;
    if (this.context) {
      try {
        const session = await UserStorageUtil.loadSession(this.context);
        if (session && session.token) {
          httpUtil.setAuthToken(session.token);
          logger.info('DataModel.deleteTasks: å·²ä»sessionæ¢å¤token: ' + session.token.substring(0, 20) + '...');
          tokenRestored = true;
        } else {
          logger.warn('DataModel.deleteTasks: sessionä¸­æ²¡æœ‰tokenï¼Œå¯èƒ½æœªç™»å½•');
          logger.warn('DataModel.deleteTasks: sessionå†…å®¹: ' + JSON.stringify(session));
        }
      } catch (err) {
        logger.error('DataModel.deleteTasks: æ¢å¤tokenå¤±è´¥: ' + JSON.stringify(err));
      }
    } else {
      logger.error('DataModel.deleteTasks: contextä¸ºç©ºï¼Œæ— æ³•æ¢å¤token');
    }
    
    if (!tokenRestored) {
      logger.error('DataModel.deleteTasks: âš ï¸ è­¦å‘Šï¼štokenæœªæ¢å¤ï¼Œè¯·æ±‚å¯èƒ½ä¼šå¤±è´¥ï¼');
    }
    
    try {
      // æ ¡éªŒè¦åˆ é™¤çš„IDæ˜¯å¦å­˜åœ¨äºæ•°æ®æºä¸­
      const validIds: string[] = [];
      taskIds.forEach(id => {
        const exists = this.targetData.some(item => item.id === id);
        if (exists) {
          validIds.push(id);
        } else {
          logger.warn(`DataModel.deleteTasks: å·¥å•ID ${id} ä¸å­˜åœ¨äºæ•°æ®æºä¸­`);
        }
      });

      if (validIds.length === 0) {
        logger.warn('DataModel.deleteTasks: æ²¡æœ‰æœ‰æ•ˆçš„å·¥å•IDå¯åˆ é™¤');
        return 0;
      }

      // åç«¯æ²¡æœ‰æ‰¹é‡åˆ é™¤æ¥å£ï¼Œæ”¹ä¸ºå¾ªç¯è°ƒç”¨å•ä¸ªåˆ é™¤æ¥å£
      logger.info('DataModel.deleteTasks: å¼€å§‹é€ä¸ªåˆ é™¤å·¥å•ï¼Œå…± ' + String(validIds.length) + ' ä¸ª');
      let deletedCount = 0;
      const failedIds: string[] = [];
      
      // è®°å½•åˆ é™¤å‰çš„å·¥å•æ•°é‡
      const beforeCount = this.targetData.length;
      
      for (let i = 0; i < validIds.length; i++) {
        const taskId = validIds[i];
        try {
          logger.info(`DataModel.deleteTasks: æ­£åœ¨åˆ é™¤ç¬¬ ${i + 1}/${validIds.length} ä¸ªå·¥å•: ${taskId}`);
          
          // æ£€æŸ¥å·¥å•æ˜¯å¦è¿˜åœ¨å†…å­˜ä¸­ï¼ˆå¯èƒ½åœ¨ä¹‹å‰çš„åˆ é™¤ä¸­å·²ç»è¢«ç§»é™¤ï¼‰
          const currentIndex = this.targetData.findIndex(item => item.id === taskId);
          if (currentIndex === -1) {
            // å·¥å•å·²ç»ä¸åœ¨å†…å­˜ä¸­ï¼Œå¯èƒ½æ˜¯ä¹‹å‰å·²ç»åˆ é™¤æˆåŠŸï¼Œæˆ–è€…å·²ç»è¢«å…¶ä»–æ“ä½œåˆ é™¤
            logger.warn(`DataModel.deleteTasks: å·¥å• ${taskId} ä¸åœ¨å†…å­˜ä¸­ï¼Œå¯èƒ½å·²åˆ é™¤ï¼Œè·³è¿‡`);
            deletedCount++;
            continue;
          }
          
          // è°ƒç”¨åç«¯APIåˆ é™¤
          const response = await apiService.deleteTask(taskId);
          
          if (response.code >= 200 && response.code < 300) {
            // ä»å†…å­˜ä¸­åˆ é™¤
            this.targetData.splice(currentIndex, 1);
            deletedCount++;
            logger.info(`DataModel.deleteTasks: å·¥å• ${taskId} åˆ é™¤æˆåŠŸ`);
          } else {
            failedIds.push(taskId);
            logger.warn(`DataModel.deleteTasks: å·¥å• ${taskId} åˆ é™¤å¤±è´¥ï¼Œå“åº”ç : ${response.code}`);
          }
        } catch (err) {
          failedIds.push(taskId);
          logger.error(`DataModel.deleteTasks: å·¥å• ${taskId} åˆ é™¤å¼‚å¸¸: ${JSON.stringify(err)}`);
        }
      }
      
      logger.info(`DataModel.deleteTasks: åˆ é™¤å®Œæˆï¼ŒæˆåŠŸ: ${deletedCount}, å¤±è´¥: ${failedIds.length}`);
      
      if (deletedCount > 0) {
        // é€šçŸ¥å˜æ›´
        this.notifyChange();
        logger.info('DataModel.deleteTasks: æ‰¹é‡åˆ é™¤å®Œæˆï¼ŒæˆåŠŸåˆ é™¤äº† ' + String(deletedCount) + ' ä¸ªå·¥å•');
      }
      
      if (failedIds.length > 0) {
        logger.warn('DataModel.deleteTasks: éƒ¨åˆ†å·¥å•åˆ é™¤å¤±è´¥: ' + JSON.stringify(failedIds));
        // å¦‚æœæœ‰å¤±è´¥çš„ï¼ŒæŠ›å‡ºå¼‚å¸¸
        throw new Error(`éƒ¨åˆ†å·¥å•åˆ é™¤å¤±è´¥ï¼ŒæˆåŠŸ: ${deletedCount}, å¤±è´¥: ${failedIds.length}`);
      }
      
      return deletedCount;
    } catch (err) {
      logger.error('DataModel.deleteTasks åˆ é™¤æ“ä½œå¼‚å¸¸:', JSON.stringify(err));
      // é‡æ–°æŠ›å‡ºå¼‚å¸¸ï¼Œè®©è°ƒç”¨æ–¹çŸ¥é“åˆ é™¤å¤±è´¥
      if (err instanceof Error) {
        throw err;
      } else {
        throw new Error(`åˆ é™¤å·¥å•å¤±è´¥: ${JSON.stringify(err)}`);
      }
    }
  }

  /**
   * è·å–ç»Ÿè®¡æ•°æ®
   */
  getStatistics(): StatisticsModel {
    const total = this.targetData.length;
    const completed = this.targetData.filter(item => item.status === TaskStatus.COMPLETED).length;
    const inProgress = this.targetData.filter(item => item.status === TaskStatus.IN_PROGRESS).length;
    const notStarted = this.targetData.filter(item => item.status === TaskStatus.PENDING).length;
    
    const completionRate = total > 0 ? Math.round((completed / total) * 100) : 0;
    const totalProgress = this.targetData.reduce((sum, item) => sum + item.progressValue, 0);
    const averageProgress = total > 0 ? Math.round(totalProgress / total) : 0;

    return {
      total,
      completed,
      inProgress,
      notStarted,
      completionRate,
      averageProgress
    };
  }

  /**
   * æ³¨å†Œæ•°æ®å˜æ›´ç›‘å¬å™¨
   */
  addChangeListener(listener: () => void): void {
    this.changeListeners.push(listener);
  }

  /**
   * ç§»é™¤æ•°æ®å˜æ›´ç›‘å¬å™¨
   */
  removeChangeListener(listener: () => void): void {
    const index = this.changeListeners.indexOf(listener);
    if (index > -1) {
      this.changeListeners.splice(index, 1);
    }
  }

  /**
   * é€šçŸ¥æ‰€æœ‰ç›‘å¬å™¨æ•°æ®å·²å˜æ›´
   */
  private notifyChange(): void {
    this.changeListeners.forEach(listener => {
      try {
        listener();
      } catch (err) {
        console.error('Error in change listener:', JSON.stringify(err));
      }
    });
  }
}

